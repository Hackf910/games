<!doctype html>
<html lang="mn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris (Canvas) - Z/X/C/Space + Arrows</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --grid:#1b2550; --text:#e9ecff; --muted:#a8b0d6;
      --cell:28px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:radial-gradient(1200px 700px at 30% 20%, #1a2a6a 0%, var(--bg) 55%);
      color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    .wrap{
      width:min(980px, 95vw);
      display:grid;
      grid-template-columns: 240px auto 240px;
      gap:14px;
      align-items:start;
    }
    .card{
      background:rgba(18,26,51,.82);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(6px);
    }
    h1{font-size:16px; margin:0 0 10px}
    .muted{color:var(--muted); font-size:13px; line-height:1.35}
    .stat{display:flex; justify-content:space-between; margin:8px 0; font-size:14px}
    .kbd{
      display:inline-block; padding:2px 8px; border-radius:10px;
      background:rgba(255,255,255,.07); border:1px solid rgba(255,255,255,.10);
      font-size:12px; color:var(--text);
      margin:2px 4px 2px 0;
    }
    canvas{
      background:
        linear-gradient(rgba(255,255,255,.06), rgba(255,255,255,.02)),
        repeating-linear-gradient(to right, rgba(255,255,255,.08) 0 1px, transparent 1px var(--cell)),
        repeating-linear-gradient(to bottom, rgba(255,255,255,.08) 0 1px, transparent 1px var(--cell));
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      display:block;
      width:calc(10 * var(--cell));
      height:calc(20 * var(--cell));
      image-rendering: pixelated;
    }
    .center{display:grid; place-items:center}
    button{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      font-weight:600;
    }
    button:hover{background:rgba(255,255,255,.10)}
    .small{font-size:12px}
    @media (max-width: 900px){
      .wrap{grid-template-columns:1fr; }
      .center{order:-1}
      canvas{justify-self:center}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <span>Hi noobs, i'm bored suren bn</span>
    <div class="card">
      <h1>Controls</h1>
      <div class="muted">
        <div><span class="kbd">←</span><span class="kbd">→</span> move</div>
        <div><span class="kbd">↓</span> soft drop</div>
        <div><span class="kbd">Space</span> hard drop</div>
        <div><span class="kbd">X</span> / <span class="kbd">↑</span> rotate CW</div>
        <div><span class="kbd">Z</span> rotate CCW</div>
        <div><span class="kbd">C</span> hold</div>
        <div><span class="kbd">P</span> pause</div>
        <div><span class="kbd">R</span> restart</div>
      </div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,.10);margin:12px 0;">
      <div class="stat"><span>Score</span><b id="score">0</b></div>
      <div class="stat"><span>Lines</span><b id="lines">0</b></div>
      <div class="stat"><span>Level</span><b id="level">1</b></div>
      <div class="stat"><span>Status</span><b id="status">Playing</b></div>
      <div style="margin-top:12px">
        <button id="restart">Restart (R)</button>
        <div class="muted small" style="margin-top:8px">
          Tip: Space дарж хурдан унагаад оноогоо хурдан цуглуулаарай.
        </div>
      </div>
    </div>

    <div class="center">
      <canvas id="game" width="280" height="560"></canvas>
    </div>

    <div class="card">
      <h1>Next / Hold</h1>
      <div class="stat"><span>Next</span></div>
      <canvas id="next" width="112" height="112" style="width:112px;height:112px;border-radius:14px;margin-bottom:12px"></canvas>
      <div class="stat"><span>Hold (C)</span></div>
      <canvas id="hold" width="112" height="112" style="width:112px;height:112px;border-radius:14px"></canvas>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,.10);margin:12px 0;">
      <div class="muted">
        Энэ нь “7-bag” random, hold, hard drop, line clear, level speed-тэй.
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== Config ======
  const COLS = 10, ROWS = 20;
  const CELL = 28;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('hold');
  const holdCtx = holdCanvas.getContext('2d');

  const ui = {
    score: document.getElementById('score'),
    lines: document.getElementById('lines'),
    level: document.getElementById('level'),
    status: document.getElementById('status'),
    restart: document.getElementById('restart'),
  };

  // Fit actual pixel size to CSS grid size
  canvas.width = COLS * CELL;
  canvas.height = ROWS * CELL;

  const COLORS = {
    I: '#7cdbff',
    O: '#ffcf6b',
    T: '#d59bff',
    S: '#8aff9a',
    Z: '#ff7fa8',
    J: '#7ef0d3',
    L: '#ffd0ff',
    G: 'rgba(255,255,255,.25)' // ghost
  };

  // Tetromino shapes (4x4)
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ]
  };

  // SRS-ish wall kicks are complex; we do a simple kick set (good enough)
  const KICKS = [
    {x: 0, y: 0},
    {x: -1, y: 0},
    {x: 1, y: 0},
    {x: -2, y: 0},
    {x: 2, y: 0},
    {x: 0, y: -1},
    {x: 0, y: 1},
  ];

  // ====== Helpers ======
  const makeBoard = () => Array.from({length: ROWS}, () => Array(COLS).fill(null));

  function rotateMatrix(mat, dir /* +1 CW, -1 CCW */){
    const N = mat.length;
    const res = Array.from({length:N}, () => Array(N).fill(0));
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        if (dir === 1) res[x][N-1-y] = mat[y][x];
        else res[N-1-x][y] = mat[y][x];
      }
    }
    return res;
  }

  function collides(board, piece, ox=0, oy=0){
    const {matrix, x, y, type} = piece;
    for (let r=0;r<matrix.length;r++){
      for (let c=0;c<matrix[r].length;c++){
        if (!matrix[r][c]) continue;
        const bx = x + c + ox;
        const by = y + r + oy;
        if (bx < 0 || bx >= COLS || by >= ROWS) return true;
        if (by >= 0 && board[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(board, piece){
    const {matrix, x, y, type} = piece;
    for (let r=0;r<matrix.length;r++){
      for (let c=0;c<matrix[r].length;c++){
        if (!matrix[r][c]) continue;
        const bx = x + c;
        const by = y + r;
        if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS){
          board[by][bx] = type;
        }
      }
    }
  }

  function clearLines(board){
    let cleared = 0;
    for (let r=ROWS-1;r>=0;r--){
      if (board[r].every(cell => cell)){
        board.splice(r,1);
        board.unshift(Array(COLS).fill(null));
        cleared++;
        r++; // recheck same row index after shift
      }
    }
    return cleared;
  }

  function drawCell(g, x, y, color, alpha=1){
    g.globalAlpha = alpha;
    g.fillStyle = color;
    g.fillRect(x*CELL, y*CELL, CELL, CELL);
    g.globalAlpha = 1;
    // subtle inner highlight
    g.fillStyle = 'rgba(255,255,255,.14)';
    g.fillRect(x*CELL+3, y*CELL+3, CELL-6, CELL-6);
  }

  function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // locked blocks
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const t = state.board[r][c];
        if (t) drawCell(ctx, c, r, COLORS[t], 0.95);
      }
    }

    // ghost
    const ghost = getGhost(state.active);
    drawPiece(ghost, true);

    // active
    drawPiece(state.active, false);
  }

  function drawPiece(piece, isGhost){
    const {matrix, x, y, type} = piece;
    for (let r=0;r<matrix.length;r++){
      for (let c=0;c<matrix[r].length;c++){
        if (!matrix[r][c]) continue;
        const bx = x + c;
        const by = y + r;
        if (by < 0) continue;
        if (isGhost) drawCell(ctx, bx, by, COLORS[type], 0.22);
        else drawCell(ctx, bx, by, COLORS[type], 0.95);
      }
    }
  }

  function drawMini(g, type){
    g.clearRect(0,0,112,112);
    if (!type) return;
    const mat = SHAPES[type];
    const miniCell = 24;
    const offX = 112/2 - (4*miniCell)/2;
    const offY = 112/2 - (4*miniCell)/2;
    for (let r=0;r<4;r++){
      for (let c=0;c<4;c++){
        if (!mat[r][c]) continue;
        g.globalAlpha = 0.95;
        g.fillStyle = COLORS[type];
        g.fillRect(offX + c*miniCell, offY + r*miniCell, miniCell, miniCell);
        g.globalAlpha = 1;
        g.fillStyle = 'rgba(255,255,255,.14)';
        g.fillRect(offX + c*miniCell + 3, offY + r*miniCell + 3, miniCell-6, miniCell-6);
      }
    }
  }

  function getGhost(piece){
    const g = clonePiece(piece);
    while (!collides(state.board, g, 0, 1)) g.y++;
    return g;
  }

  function clonePiece(p){
    return {
      type: p.type,
      matrix: p.matrix.map(row => row.slice()),
      x: p.x, y: p.y
    };
  }

  // 7-bag random
  function newBag(){
    const arr = ['I','O','T','S','Z','J','L'];
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function spawn(type){
    const mat = SHAPES[type].map(r => r.slice());
    // spawn near top center
    return { type, matrix: mat, x: Math.floor(COLS/2)-2, y: -1 };
  }

  // Scoring (roughly guideline-like)
  function addScore(linesCleared, hardDropCells, softDropCells){
    // drops
    state.score += hardDropCells * 2 + softDropCells * 1;

    // line clears
    const base = [0, 100, 300, 500, 800]; // 0..4
    state.score += base[linesCleared] * state.level;

    if (linesCleared > 0){
      state.lines += linesCleared;
      const newLevel = Math.floor(state.lines / 10) + 1;
      if (newLevel !== state.level){
        state.level = newLevel;
        state.dropInterval = Math.max(80, 700 - (state.level-1) * 60);
      }
    }
    syncUI();
  }

  function syncUI(){
    ui.score.textContent = state.score;
    ui.lines.textContent = state.lines;
    ui.level.textContent = state.level;
    ui.status.textContent = state.paused ? 'Paused' : (state.gameOver ? 'Game Over' : 'Playing');
    drawMini(nextCtx, state.next);
    drawMini(holdCtx, state.hold);
  }

  // ====== Game State ======
  const state = {
    board: makeBoard(),
    bag: [],
    active: null,
    next: null,
    hold: null,
    canHold: true,
    score: 0,
    lines: 0,
    level: 1,
    dropInterval: 700,
    lastTime: 0,
    acc: 0,
    paused: false,
    gameOver: false,
    softDropping: false,
    softDropCells: 0,
  };

  function pickNextType(){
    if (state.bag.length === 0) state.bag = newBag();
    return state.bag.pop();
  }

  function reset(){
    state.board = makeBoard();
    state.bag = newBag();
    state.score = 0; state.lines = 0; state.level = 1;
    state.dropInterval = 700;
    state.paused = false; state.gameOver = false;
    state.hold = null; state.canHold = true;

    state.next = pickNextType();
    state.active = spawn(pickNextType());
    // next already set, so shift
    state.next = pickNextType();

    // if spawn collides -> game over (rare)
    if (collides(state.board, state.active, 0, 0)){
      state.gameOver = true;
    }
    syncUI();
    drawBoard();
  }

  function lockAndContinue(){
    merge(state.board, state.active);
    const cleared = clearLines(state.board);
    addScore(cleared, 0, 0);

    // spawn new
    state.active = spawn(state.next);
    state.next = pickNextType();
    state.canHold = true;
    state.softDropCells = 0;

    if (collides(state.board, state.active, 0, 0)){
      state.gameOver = true;
      syncUI();
    }
  }

  function move(dx){
    if (state.paused || state.gameOver) return;
    if (!collides(state.board, state.active, dx, 0)){
      state.active.x += dx;
      drawBoard();
    }
  }

  function softDrop(){
    if (state.paused || state.gameOver) return;
    if (!collides(state.board, state.active, 0, 1)){
      state.active.y += 1;
      state.softDropCells += 1;
      addScore(0, 0, 1);
      drawBoard();
    } else {
      lockAndContinue();
      drawBoard();
    }
  }

  function hardDrop(){
    if (state.paused || state.gameOver) return;
    let cells = 0;
    while (!collides(state.board, state.active, 0, 1)){
      state.active.y += 1;
      cells++;
    }
    addScore(0, cells, 0);
    lockAndContinue();
    drawBoard();
  }

  function rotate(dir){
    if (state.paused || state.gameOver) return;
    const rotated = rotateMatrix(state.active.matrix, dir);
    const old = state.active.matrix;
    state.active.matrix = rotated;

    // simple kick attempts
    for (const k of KICKS){
      if (!collides(state.board, state.active, k.x, k.y)){
        state.active.x += k.x;
        state.active.y += k.y;
        drawBoard();
        return;
      }
    }
    // revert if all kicks fail
    state.active.matrix = old;
  }

  function hold(){
    if (state.paused || state.gameOver) return;
    if (!state.canHold) return;

    const curType = state.active.type;
    if (!state.hold){
      state.hold = curType;
      state.active = spawn(state.next);
      state.next = pickNextType();
    } else {
      const swap = state.hold;
      state.hold = curType;
      state.active = spawn(swap);
    }
    state.canHold = false;

    if (collides(state.board, state.active, 0, 0)){
      state.gameOver = true;
    }
    syncUI();
    drawBoard();
  }

  function togglePause(){
    if (state.gameOver) return;
    state.paused = !state.paused;
    syncUI();
  }

  // ====== Loop ======
  function tick(time){
    requestAnimationFrame(tick);
    if (state.paused || state.gameOver) return;

    const dt = time - state.lastTime;
    state.lastTime = time;
    state.acc += dt;

    if (state.acc >= state.dropInterval){
      state.acc = 0;
      // gravity step
      if (!collides(state.board, state.active, 0, 1)){
        state.active.y += 1;
      } else {
        lockAndContinue();
      }
      drawBoard();
    }
  }

  // ====== Input ======
  const heldKeys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key;
    // prevent scroll on arrows/space
    if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(k)) e.preventDefault();

    if (heldKeys.has(k)) return; // simple key repeat guard for some actions
    heldKeys.add(k);

    const key = k.toLowerCase();
    if (key === 'p') togglePause();
    if (key === 'r') reset();

    if (state.paused || state.gameOver) return;

    switch (k){
      case 'ArrowLeft': move(-1); break;
      case 'ArrowRight': move(1); break;
      case 'ArrowDown': softDrop(); break;
      case 'ArrowUp': rotate(1); break;
      case ' ': hardDrop(); break;
      default:
        if (key === 'z') rotate(-1);
        if (key === 'x') rotate(1);
        if (key === 'c') hold();
        break;
    }
  });

  window.addEventListener('keyup', (e) => {
    heldKeys.delete(e.key);
  });

  ui.restart.addEventListener('click', reset);

  // Start
  reset();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
